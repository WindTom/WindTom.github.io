<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WindTom</title>
    <description></description>
    <link>http://windtom.github.io/</link>
    <atom:link href="http://windtom.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Jul 2016 02:55:26 +0800</pubDate>
    <lastBuildDate>Sat, 30 Jul 2016 02:55:26 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>数据挖掘平台-R语言与Hadoop</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;几种流行的开源数据挖掘平台&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#r&quot; id=&quot;markdown-toc-r&quot;&gt;R&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#weka&quot; id=&quot;markdown-toc-weka&quot;&gt;Weka&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tanagra&quot; id=&quot;markdown-toc-tanagra&quot;&gt;Tanagra&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rapidminer&quot; id=&quot;markdown-toc-rapidminer&quot;&gt;RapidMiner&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#knime&quot; id=&quot;markdown-toc-knime&quot;&gt;KNIME&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#orange&quot; id=&quot;markdown-toc-orange&quot;&gt;Orange&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ggobi&quot; id=&quot;markdown-toc-ggobi&quot;&gt;GGobi&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#r-1&quot; id=&quot;markdown-toc-r-1&quot;&gt;R语言大数据挖掘应用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#r-2&quot; id=&quot;markdown-toc-r-2&quot;&gt;R语言是否适用企业级大数据挖掘应用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#hadoop&quot; id=&quot;markdown-toc-hadoop&quot;&gt;Hadoop家族&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rhadoop&quot; id=&quot;markdown-toc-rhadoop&quot;&gt;R语言如何与Hadoop结合？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（注：本文资料来源于互联网）&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;几种流行的开源数据挖掘平台&lt;/h2&gt;

&lt;h3 id=&quot;r&quot;&gt;R&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.r-projectorg&quot;&gt;R&lt;/a&gt;是用于&lt;strong&gt;统计分析&lt;/strong&gt;和&lt;strong&gt;图形化&lt;/strong&gt;的计算机语言及分析工具。Ｒ支持一系列分析技术，包括统计检验，预测建模，数据可视化等等。在官网上能找到众多的开源扩展包。&lt;/p&gt;

&lt;h3 id=&quot;weka&quot;&gt;Weka&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.waikato.ac.nz/ml/weka/&quot;&gt;Weka&lt;/a&gt;可能是名气最大的开源机器学习和数据挖掘软件。高级用户可以通过Java编程和命令行来调用其分析组件。同时Weka也提供图形化界面。和R相比，Weka在统计分析方面较弱，但在机器学习方面强得多。在&lt;a href=&quot;http://weka.wikispaces.com/Related+Projects&quot;&gt;Weka论坛&lt;/a&gt;可以找到很多扩展包，包括文本挖掘、可视化、网格计算等等。很多其它开源数据挖掘软件也支持调用Weka的分析功能。&lt;/p&gt;

&lt;h3 id=&quot;tanagra&quot;&gt;Tanagra&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://eric.univ-lyon2.fr/~ricco/tanagra/en/tanagra.html&quot;&gt;Tanagra&lt;/a&gt;是使用图形界面的数据挖掘软件，采用了树状结构来组织分析组件。Tanagra缺乏高级的可视化能力，但它的强项是统计分析，提供了众多的有参和无参检验方法，同时它的特征选取方法也很多。&lt;/p&gt;

&lt;h3 id=&quot;rapidminer&quot;&gt;RapidMiner&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://rapidminer.com/&quot;&gt;RapidMiner&lt;/a&gt;是预测性分析和数据挖掘软件，使用Java语言开发，具有拖曳操作、无需编程、运算速度快的特点，有开源和商业两种版本。RapidMiner可以被用来搭建推荐系统和评论挖掘系统，它有一些很有用的扩展包。比如，推荐系统扩展包rmx_irbrecommender-ANY-5.0.4.jar可以直接实现基于内容的和基于协同过滤的推荐系统。信息抽取扩展包rapidminer-Information-Extraction-1.0.2.jar可以用于实现特征和观点词的提取，若再配合RapidMiner提供的文本分类功能，应该可以实现一个评论挖掘原型系统（作者xiaoli的观点，她同时提供了用RapidMiner搭建推荐系统和评论挖掘系统的&lt;a href=&quot;http://blog.sina.com.cn/s/blog_73de143c010156sb.html&quot;&gt;具体方法&lt;/a&gt;。同时她的博客也提出了一些关于学习推荐系统应该思考的问题）。&lt;/p&gt;

&lt;h3 id=&quot;knime&quot;&gt;KNIME&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.knime.org/&quot;&gt;KNIME&lt;/a&gt;是基于Eclipse开发环境精心开发的数据挖掘工具。工具无需安装，也是基于Java开发，可以扩展使用Weka中的挖掘算法。和YALE不同的是，KNIME采用的是类似数据流的方式建立分析挖掘流程。挖掘流程由一系列功能节点组成，每个节点有输入/输出端口（port），用于接收数据或模型、导出结果。&lt;a href=&quot;http://www.360doc.com/content/11/0212/19/5696310_92510422.shtml&quot;&gt;网上文章&lt;/a&gt;指出KNIME比Weka的KnowledgeFlow更好用，连接节点时很方便，直接用鼠标拖拽连接端口即可。而Weka中则需要在节点上按鼠标右键，再选择后续节点，比较麻烦。&lt;/p&gt;

&lt;h3 id=&quot;orange&quot;&gt;Orange&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://orange.biolab.si/&quot;&gt;Orange&lt;/a&gt;是类似KNIME和Weka KnowledgeFlow的数据挖掘工具，它的图形环境称为Orange画布(OrangeCanvas)，用户可以在画布上放置分析控件，然后把控件连接起来组成挖掘流程。Orange的强项在于提供了大量可视化方法，可以对数据和模型进行多种图形化展示，并能智能搜索合适的可视化形式，支持对数据的交互式探索。弱项在于传统统计分析能力不强，不支持统计检验，报表能力也有限。Orange允许用户使用Python脚本语言进行扩展开发。&lt;/p&gt;

&lt;h3 id=&quot;ggobi&quot;&gt;GGobi&lt;/h3&gt;
&lt;p&gt;用于交互式可视化的开源软件，使用Brushing的方法。GFobi可以用作R软件的插件，或者通过Perl,Python等脚本语言来调用。网上文章(链接见上文)推荐使用KNIME，同时安装Weka和R扩展包。&lt;/p&gt;

&lt;h2 id=&quot;r-1&quot;&gt;R语言大数据挖掘应用&lt;/h2&gt;

&lt;p&gt;使用R语言在Hadoop平台上进行分析，可采用的方式有：
Ｒ语言的RJDBC包链接Hive传递SQL进行数据的查询和导入，得到的数据在R语言里面进行数据预处理于算法建模，再把分析模型的结果存储到本地的MySQL，然后提供作为PHP的数据查询，从而让PHP进行分析挖掘后台的数据可视化处理。这样就形成了一条“可视化数据挖掘闭环”(Visual Data Mining Closed Loop)&lt;/p&gt;

&lt;h3 id=&quot;r-2&quot;&gt;R语言是否适用企业级大数据挖掘应用&lt;/h3&gt;

&lt;p&gt;作者&lt;a href=&quot;http://www.bjt.name/&quot;&gt;刘思喆&lt;/a&gt;在文章&lt;a href=&quot;http://www.thebigdata.cn/JieJueFangAn/12031.html&quot;&gt;R语言企业级大数据挖掘应用&lt;/a&gt;中提出一个看似另类的解决方案——在企业级数据挖掘中使用R语言＋Hadoop的方式。&lt;/p&gt;

&lt;p&gt;之所以使用R语言是因为开源软件可以根据业务的变化进行调整，但商业软件往往很难做到。&lt;/p&gt;

&lt;p&gt;使用R语言进行大数据处理需要注意到是避免使用C++或Java式的编程思想，而是要使用类似于matlab的&lt;code class=&quot;highlighter-rouge&quot;&gt;向量化&lt;/code&gt;编程思想。&lt;/p&gt;

&lt;p&gt;R语言能够处理GB级数据，但是底层数据是PB级应该怎么办？刘给出了如下图示：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;http://www.thebigdata.cn/upload/2014-10/141008110780412.png&quot; /&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;p&gt;从图上看出，针对不同业务场景的数据集市，通过数据清洗已经下降到TB级，再往上是针对特定任务的分析和挖掘模块，数据被整理到GB级，这时候R语言就能够比较方便地处理了。&lt;/p&gt;

&lt;h3 id=&quot;hadoop&quot;&gt;Hadoop家族&lt;/h3&gt;

&lt;p&gt;Hadoop的家族成员：Hive, HBase, Zookeeper, Avro, Pig, Ambari, Sqoop, Mahout, Chukwa&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hive&lt;/strong&gt;: 是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pig&lt;/strong&gt;: 是一个基于Hadoop的大规模数据分析工具，它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HBase&lt;/strong&gt;: 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sqoop&lt;/strong&gt;: 是一个用来将Hadoop和关系型数据库中的数据相互转移的工具，可以将一个关系型数据库（MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zookeeper&lt;/strong&gt;: 是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，简化分布式应用协调及其管理的难度，提供高性能的分布式服务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mahout&lt;/strong&gt;: 是基于Hadoop的机器学习和数据挖掘的一个分布式框架。Mahout用MapReduce实现了部分数据挖掘算法，解决了并行挖掘的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Avro&lt;/strong&gt;: 是一个数据序列化系统，设计用于支持数据密集型，大批量数据交换的应用。Avro是新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ambari&lt;/strong&gt;: 是一种基于Web的工具，支持Hadoop集群的供应、管理和监控。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chukwa&lt;/strong&gt;: 是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合 Hadoop 处理的文件保存在 HDFS 中供 Hadoop 进行各种 MapReduce 操作。&lt;/p&gt;

&lt;h3 id=&quot;rhadoop&quot;&gt;R语言如何与Hadoop结合？&lt;/h3&gt;

&lt;p&gt;作者&lt;a href=&quot;http://www.36dsj.com/archives/6468&quot;&gt;张丹&lt;/a&gt;提到，当前已经有很多比较好的结合点出现。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;RHadoop。
RHadoop是Hadoop与R语言结合的开源产品。RHadoop包含三个R包 (rmr，rhdfs，rhbase)，分别对应Hadoop系统架构中的MapReduce, HDFS, HBase三个部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RHiveRHive是一款通过R语言直接访问Hive的工具包，由韩国公司NexR研发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重写Mahout。用R语言重写Mahout的实现也是一种结合的思路，我也做过相关的尝试。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hadoop调用R。上面说的都是R如何调用Hadoop，当然我们也可以反相操作，打通JAVA和R的连接通道，让Hadoop调用R的函数。但是，这部分还没有商家做出成形的产品。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;R和Hadoop在实际中的案例&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 30 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/30/R-And-Hadoop/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/30/R-And-Hadoop/</guid>
        
        <category>R</category>
        
        <category>Hadoop</category>
        
        <category>大数据</category>
        
        <category>数据挖掘</category>
        
        
        <category>大数据挖掘</category>
        
      </item>
    
      <item>
        <title>大数据分析工具</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;大数据分析的六大最好工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;大数据分析八大工具&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;大数据全栈式开发语言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;(注：本文内容来自互联网)&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;大数据分析的六大最好工具&lt;/h2&gt;

&lt;p&gt;原文链接见&lt;a href=&quot;http://www.he11oworld.com/cloud/1145.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;此文总结来说就是介绍了大数据分析的几个工具，分别是：
1. Hadoop
2. HPCC(高性能计算与通信)
3. Storm。开源软件，一个分布式、容错的实时计算系统。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;大数据分析八大工具&lt;/h2&gt;
&lt;p&gt;原文&lt;a href=&quot;http://tieba.baidu.com/p/3866999054&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;大数据全栈式开发语言&lt;/h2&gt;
&lt;p&gt;原文&lt;a href=&quot;http://insights.thoughtworkers.org/full-stack-python/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/29/Big-Data-Analysis-tool/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/29/Big-Data-Analysis-tool/</guid>
        
        <category>大数据</category>
        
        <category>数据挖掘</category>
        
        <category>Hadoop</category>
        
        <category>R</category>
        
        
        <category>大数据挖掘</category>
        
      </item>
    
      <item>
        <title>超声、超声心动图和多普勒基础入门（四）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;二维成像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;二维成像&lt;/h2&gt;

</description>
        <pubDate>Sun, 24 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/24/ultrasound-intro-2d-imaging/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/24/ultrasound-intro-2d-imaging/</guid>
        
        <category>ultrasound</category>
        
        
        <category>ultrasound</category>
        
      </item>
    
      <item>
        <title>超声、超声心动图和多普勒基础入门（三）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#m-mode&quot; id=&quot;markdown-toc-m-mode&quot;&gt;M-mode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;深度分辨率、带宽&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;关于超声脉冲&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;英文原文链接： &lt;br /&gt;
（http://folk.ntnu.no/stoylen/strainrate/Basic_ultrasound#ultrasound）&lt;/p&gt;

&lt;h2 id=&quot;m-mode&quot;&gt;M-mode&lt;/h2&gt;

&lt;p&gt;M型超声是能够记录并显示心脏运动的第一种超声设备。下图为典型的M-型超声图像。&lt;/p&gt;

&lt;div&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td colspan=&quot;3&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/vvpslax.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/vvmm.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/mvmm.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/aomm.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td colspan=&quot;3&quot;&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;图：典型的M-型超声成像。a是左心室成像。b是二尖瓣成像。c是主动脉血管成像（二维长轴）。这里振幅表现为白色的亮度。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;深度分辨率、带宽&lt;/h2&gt;

&lt;p&gt;超声波深度分辨率指的是沿波束方向的分辨率，这取决于发射出来的超声脉冲长度。在血液和组织交界处能够看到一条明亮的分界线，但这反映出来的是脉冲长度，并不是组织结构（尤其不是指内膜，因为内膜太薄，现有超声频率根部看不到）。也是这个原因，美国超声心动协会（ASE）规定用超声的前锋到前锋距离作为深度。（这句话不好懂，也许看完下面的内容会明白）&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;关于超声脉冲&lt;/h3&gt;
&lt;p&gt;这里稍微插一段。你可能不知道上面一直在讲超声波，这里怎么又出现超声脉冲。好了，&lt;a href=&quot;http://www.ultrasonix.com/wikisonix/index.php/Transmitting_Ultrasound_Pulses&quot;&gt;维基百科&lt;/a&gt;是这么解释的：&lt;/p&gt;

&lt;p&gt;超声波脉冲是能够在生物体组织中传播的机械波。要制造出这种脉冲，需使用超声换能器（ultrasound transducer），它能将机械能转换成电能，同样也能将电能转换为机械能。&lt;/p&gt;

&lt;div&gt;&lt;hr /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;时间上的超声波脉冲形状&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获得组织图像的超声波有两种类型：&lt;/p&gt;

&lt;p&gt;脉冲波&lt;img src=&quot;http://www.ultrasonix.com/wikisonix/images/thumb/2/2d/Pulse.jpg/300px-Pulse.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
连续波&lt;img src=&quot;http://www.ultrasonix.com/wikisonix/images/thumb/e/e8/CW.jpg/300px-CW.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;脉冲波的获取方式为：给超声换能器施加短时间电信号（电脉冲）。没有换能器能够转换出与电脉冲形状一模一样的超声脉冲。决定发射出来的脉冲形状的因素不仅是施加的电脉冲形状，还有换能器对频率的反应。将电脉冲施加到换能器上就好比拿一根木棒敲钟，即使木棒不再敲打，钟还是会继续响。下图所示为换能器输入电脉冲，输出机械脉冲：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;br /&gt;
&lt;img src=&quot;http://www.ultrasonix.com/wikisonix/images/thumb/1/18/TransFiltering.jpg/450px-TransFiltering.jpg&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cis.rit.edu/research/ultrasound/ultrasoundintro/ultraintro.html&quot;&gt;脉冲&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;频率、周期、波长和传播速度足以描述连续超声波。周期性循环，不断往复……。&lt;/p&gt;

&lt;p&gt;超声波扫描术使用的是脉冲超声，它也是周期性的超声波，相邻周期之间具有间隔，而这段时间间隔之内没有信号。如下图：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;http://www.cis.rit.edu/research/ultrasound/ultrasoundintro/pulsed.png&quot; width=&quot;70%&quot; /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://www.cis.rit.edu/research/ultrasound/ultrasoundintro/pulsentissue.png&quot; width=&quot;70%&quot; /&gt;  
&lt;br /&gt;
&lt;hr /&gt;
&lt;/div&gt;

&lt;p&gt;让我们回到深度分辨率、带宽的讨论。&lt;/p&gt;

&lt;p&gt;理想情况下，图像（B型和M型超声）中的脉冲长度应该尽可能短，但这取决于探头的物理特性。Most probes will ring in the resonance frequency for a few oscillations, and thus produce a pulse with a length of several oscillations. By Fourier analysis, the frequency content of the pulse will be less dispersed, the longer the pulse is. Thus, the pulse length is inversely proportional with  the spread of the frequency, i.e. the bandwidth of the pulse, as shown below. This will have consequences for Doppler imaging, where frequencies, and not amplitudes are analysed. （这句话很难理解，feel it!）&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Bandwidth.GIF?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt; 图：具有相同频率、不同持续时间（脉冲长度或者说震荡次数）的两个不同脉冲。较短的脉冲具有更宽的频率色散（dispersion），也就是更大的带宽。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;

&lt;p&gt;震荡次数相同的情况下表，更高的频率会导致脉冲更短，也就是说在不增加带宽的情况下缩短脉冲长度。对于成像来说，理想的脉冲应该是最高的频率，最短的脉冲长度。不过，由于噪声不均匀地分布在不同频域，谐波成像（which analyses at half the frequency）会减少噪声。给定频率，谐波成像将拉长脉冲长度，这样的结果是成像物体更厚。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/pulse%20length%20vs%20frequency.GIF?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;频率降半导致单位时间内的震荡次数更少。像二次谐波成像中将频率减半会导致更长的脉冲长度，但带宽几乎不受影响。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;br /&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;div align=&quot;center&quot;&gt;&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;
&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/2harmsurface.JPG?raw=true&quot; /&gt;
&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/leadingtoleading.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;左为二次谐波成像(1.7/3.5 MHz),右为原图像。由于谐波成像将频率减半，导致血液和隔膜交界处的回声(echo)更厚，但腔室内噪声明显减少。 &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;表面回声（surface echos）的厚度取决于脉冲长度和频率。这张隔膜的成像展示了ASE 的leading-edge to leading-edge 测量方法，方法中减去了魔宠长度。而Penn方法将两侧交界面都包含了进去，导致对厚度估计过高。（博主注：原文没有说清楚，导致此处理解不是很明白） &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/23/ultrasound-intro-3/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/23/ultrasound-intro-3/</guid>
        
        <category>ultrasound</category>
        
        
        <category>ultrasound</category>
        
      </item>
    
      <item>
        <title>超声、超声心动图和多普勒基础入门（二）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;&lt;strong&gt;吸收&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;超声功率/机械指数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;衰减&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;增益&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;时间增益补偿&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;压缩和拒绝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;英文原文链接： &lt;br /&gt;
（http://folk.ntnu.no/stoylen/strainrate/Basic_ultrasound#ultrasound）&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;吸收&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;入射超声波的一部分被组织吸收，转化成热量。这表示被吸收的能量过高可能导致生物反应。&lt;/p&gt;

&lt;p&gt;细胞吸收超声波的问题必须受到重视，原因有二：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;细胞被加热程度决定了超声设备的安全标准。被吸收的能量应该被限制在不足以破坏组织细胞。如今，细胞吸收率已经能够被计算并且应用于商业医疗设备的标准之中（被称为机械指数（mechanical index））。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;超声波能量衰减。细胞吸收是超声波束穿透能力（穿透深度）的主要障碍。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;决定能量吸收能力的因素有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;组织密度。密度越高，吸收越多。所以超声波在媒介中的衰减率为液体&amp;lt;脂肪&amp;lt;肌肉&amp;lt;纤维组织&amp;lt;钙化和骨头&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;超声波束频率。频率越高，吸收越高。超声在人体组织内衰减情况大概为 1 db/cm MHz。（不过，这是单向的衰减数据，实际中要考虑到超声波要走一个来回才能成像）。因此，探查的深度确定后，就可以决定超声频率上限。虽然加大发射的超声波能量也能提高穿透深度，但这无疑会增加被吸收的能量，而组织吸收能量是有限制的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;超声功率/机械指数&lt;/h2&gt;

&lt;p&gt;超声功率指的是探头发射能量的振幅，也就是发射进病人身体内的总能量，单位是分贝。&lt;/p&gt;

&lt;p&gt;机械指数指的是病人吸收的能量。这不仅取决于超声功率，还取决于波束对焦点（波束对焦的区域最高），但随着深度的增加而减弱。机械指数是衡量超声波生物反应的一个指标，医疗设备上标注的一般是最大值。通常，机械指数在1.5（B型超声）到0.1之间。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;衰减&lt;/h2&gt;

&lt;p&gt;超声波在传输过程中由于反射和散射会产生衰减。因此可以想象，为了成像就必须反射回部分超声波，而这会导致衰减。&lt;/p&gt;

&lt;p&gt;基本上，高反射率的物体会导致图像上产生衰减阴影（如下图）。位于低密度（反射率）器官背后的组织会更明亮。&lt;/p&gt;
&lt;div&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;th width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation.GIF?raw=true&quot; /&gt;&lt;/th&gt;
&lt;th width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Ultrasound%20gallstones.JPG?raw=true&quot; /&gt;&lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;p&gt;	&lt;small&gt;&lt;b&gt;上图为位于不同反射率结构后面的同一个匀质组织（比如肝脏）的成像示意图。高反射率细胞组织（如钙化组织）的背后会产生高衰减（图上左侧白色圆圈），因此其后面的扇区看起来明显更暗，甚至可能完全是阴影。低反射率组织结构（如液体）的背后衰减就很轻（右侧黑色圆圈），其后面的组织能接受到更多的超声波，在成像上与周围组织相比看起来更密（明亮）。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;p&gt;	&lt;small&gt;&lt;b&gt;上图为肝脏组织的成像，其前面有胆囊，胆囊中又含有高密度的结石，造成结石后方出现阴影。胆囊中的其余地方充满液体，因此位于这些部位后方的扇区密度更大，看起来也更明亮或称coloring&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
衰减大约造成10%的能量损失，加上超声波的衍射，能够被反射回来成像的能量就更少。不过最主要的原因是细胞吸收。另外，衰减随着深度的增加也加重，再加上回程的能量损失，反射回探头的能量就更少了。&lt;/p&gt;

&lt;p&gt;衰减是限制超声波束穿透深度（这个深度指的是超声波发射出去后，探头仍能接收到有效信号的距离）的主要因素。波长越短，衰减越大，穿透距离也越短。&lt;/p&gt;

&lt;p&gt;有效的距离大概在200-300x（这个单位在原文中也看不清）。临床上，质量好的成像的穿透参数大约为3.5MHz 10~20cm（成人心脏探查量），5MHz 5~10cm（儿科心脏探查），7.5 MHz 2~5cm, 10 MHZ 1~4 cm。后两个频率应用在血管探查。不过，避开衰减的途径之一是谐波成像（harmonic imaging）。也就是说，以一定频率发射出去的波束，探头接收到信号后以两倍频率进行分析（傅里叶分析），这提高了反射信号的信噪比，而不会有分辨率损失，尤其是在图像的最深处。（&lt;em&gt;什么是最深处？指图像上远离发射源的位置&lt;/em&gt;）&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;增益&lt;/h2&gt;

&lt;p&gt;增益（gain）可以对抗衰减，方法是在后处理中对反射信号进行增益补偿。不过加大增益补偿的同时也提高了信噪比（&lt;strong&gt;疑问：这是好事还是坏事？&lt;/strong&gt;）。增益补偿可以在获得图像的同时进行，也可以在后期处理中进行。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation.jpg?raw=true&quot; /&gt;
&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation%20gain.jpg?raw=true&quot; /&gt;
&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;b&gt;&lt;small&gt;未补偿的图像。可看到信号强度（可见度）随着深度不断衰减&lt;/small&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;b&gt;&lt;small&gt;增益补偿的图像。加大了信号的振幅，使得扇区后端组织结构更为清晰。不过扇区前端同样被增强，包括腔室内的噪声，因此该部分区域对比度降低。&lt;/small&gt;&lt;/b&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;时间增益补偿&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;现今所有的商业超声设备上都具有时间增益补偿（time gain compensation，TGC）功能。即根据传输时间对反射信号进行增益补偿，相当于根据距离进行增益补偿。不过这种方案并不理想，如果噪声不随着深度衰减或者随着深度衰减的程度不一，可能降低信噪比，导致某个深度产生灰度模糊。好处是能够获得更为平衡的图像，而且能够补偿大部分衰减。在谐波成像出现之前，TGC是可以调节的。由于谐波成像去除了很大部分腔室噪声，现在大多数设备采用自动TGC，但是保留了手动设置选项。时间增益补偿是一项预处理功能，必须在获得图像的同时进行处理。&lt;/p&gt;
&lt;div&gt;&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;下图为TGC控制按钮。每个滑动按钮控制某个深度上的增益水平  &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;在老旧型号上，为了获得平衡图像必须手动设置TGC!  &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/TGC1.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/TGC2.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation%20tgc.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt; 如今的设备都有自动TGC，所以为获得平衡图像滑动按钮都应该放在中间&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;按照老习惯设置按钮会导致双倍增益补偿，造成低端增益过大，而顶端又太小 &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/TGC1.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/TGC2.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;


&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/attenuation%20tgc.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/double%20tgc.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;压缩和拒绝&lt;/h2&gt;

&lt;p&gt;低振幅信号可以通过拒绝函数（reject function）过滤掉，比如过滤腔室噪声，代价是可能丢失有用的低振幅信号。&lt;/p&gt;

&lt;p&gt;最后，灰度级被压缩（compressed）制造出更加陡峭的饱和曲线（saturation curve）。意思就是图像在低振幅达到全饱和（纯黑，&lt;strong&gt;注意原文说纯白，但我理解的是纯黑&lt;/strong&gt;），同时低振幅的亮度被降低。&lt;/p&gt;

&lt;p&gt;需要注意的是本节提到的都是后处理函数，不会改善信号质量或原始信噪比。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/default.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Gain%20and%20reject.GIF?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;默认增益、拒绝和压缩设置下得到的图像  &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;增益、拒绝和压缩原理。所有曲线反映的都是亮度和被拒绝信号振幅之间的关系。黑色曲线为常规增益。提高增益补偿（红色曲线）会提高包括噪声以及灰度最弱的点在内的所有信号的强度，缺点是除了增强信号外，强度值较大的信号达到饱和值，可能导致图像的细节消失。蓝色曲线表示的是压缩，压缩能够产生更为陡峭的亮度曲线，让本来灰暗的信号更加灰暗，明亮的信号更加明亮，因此弱信号可能同背景噪声一起消失，而强信号达到饱和值，导致细节丢失。最后，浅灰色区域表示的是拒绝操作，该操作将低于某一阈值的所有信号都设为黑色。结合高增益补偿和拒绝操作将会产生同压缩操作类似的效果.&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/higain.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/reject.png?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/logain.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/compr.jpg?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;相同图像采用高增益补偿（上图）提高了心内膜的亮度，但亮度饱和导致细节丢失以及腔室内噪声增大。低增益补偿（下图）导致腔室内噪声下降，但细节丢失（如侧壁心内膜） &lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;  相同图像采用高拒绝（上图）操作导致图像腔室噪声降低，但同样细节丢失（侧壁心内膜）。压缩操作（下图）提高了亮度导致心肌细节减少&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;
&lt;br /&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/23/ultrasound-intro-2/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/23/ultrasound-intro-2/</guid>
        
        <category>ultrasound</category>
        
        <category>超声</category>
        
        
        <category>ultrasound</category>
        
      </item>
    
      <item>
        <title>超声、超声心动图和多普勒基础入门（一）</title>
        <description>&lt;hr /&gt;
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;超声&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;什么是超声数据？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;超声成像&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;反射和散射&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;英文原文链接: 
（http://folk.ntnu.no/stoylen/strainrate/Basic_ultrasound#ultrasound）&lt;/p&gt;

&lt;p&gt;本文的目的是尽量以图片介绍超声心动图和多普勒基础知识。&lt;/p&gt;

&lt;p&gt;题外话：看老外的科普性的文章，最大的感受就是直观，很容易让人明白，而国人总喜欢取术语，而且取名又让人很难理解其中的含义。百度上搜一个问题，不同的博客给的都是同一个答案。如果我们都能少一些拷贝粘贴，多写一些理解性的话，那别人学起来就容易多了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;超声&lt;/h3&gt;
&lt;p&gt;简单来说，超声就是声波，和人的声音一样，只是你听不见而已。声音是纵波，沿声音传播方向前后振荡。 
人能听见的声音大概在15000到20000赫兹，而临床上超声的频率在1000到12000赫兹。我们能墙角拐弯处能听见声音，是因为声音在这些弯角处发生衍射；高频（短波长）声音则会像电磁波一样沿直线传播，遇到物体时反射回来的波束能量也更为集中，就像光束的反射一样。因为波长短，高频声波更易在较小的物体上发生发射，且在气态媒介中不易传播。 
高中物理课本告诉我们波长和频率f成反比，它们与速度v的关系是:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/gongshi.gif?raw=true&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;声波在不同媒介中的速度不同。&lt;/p&gt;

&lt;p&gt;脉冲电压加在晶片上，晶体产生振动，从而产生超声波，我们叫这种晶体为压电晶体。同一个晶体可以作为反射超声波的接收者。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;什么是超声数据？&lt;/h2&gt;

&lt;p&gt;超声数据按照复杂度可作如下分类：&lt;/p&gt;
&lt;div&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;2&quot;&gt; 
   
&lt;tr&gt;
&lt;th width=&quot;33%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/RF.GIF?raw=true&quot; /&gt;&lt;/th&gt;

&lt;th width=&quot;33%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/RF-ampl.GIF?raw=true&quot; width=&quot;45%&quot; /&gt;        &lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/ampl.GIF?raw=true&quot; width=&quot;45%&quot; /&gt;&lt;/th&gt;

&lt;th width=&quot;33%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/freq.GIF?raw=true&quot; /&gt; &lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;span&gt;&lt;small&gt;&lt;b&gt;通常，接收到的反射超声回波是一个波形（也称RF Data），但是存储这种波形对存储空间要求很大，因为波形曲线上每个点都要求能够表达出来。不过，如果能够将RF Data存储下来，回波的振幅和频率也能借此计算出来。&lt;/b&gt;&lt;/small&gt;&lt;/span&gt; 
&lt;/td&gt;
&lt;td&gt;&lt;small&gt;&lt;span&gt;&lt;b&gt;超声回波具有振幅，只存储振幅的开销要少得多。这也是灰度成像中使用的唯一数据，比如B型和M型超声中各点（散射体对应着各个点）的亮度就是振幅信息。&lt;/b&gt;&lt;/span&gt;&lt;/small&gt;			   
&lt;/td&gt;
&lt;td&gt;&lt;small&gt;&lt;span&gt;&lt;b&gt;同样，超声回波也具有频率信息，这些信息同样可以作为像素值，在图像上显示出来。比如多普勒成像。另外，这种数据对存储空间的要求比RF Data少很多。&lt;/b&gt;&lt;/span&gt;&lt;/small&gt; 
&lt;/td&gt;
&lt;/tr&gt;
      
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;超声成像&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;反射和散射&lt;/h3&gt;

&lt;p&gt;一般来说，所有超声成像的原理都是，发射出去的超声波在经过两个组织的边界时，部分能量被反射回来。如下图三条竖线代表三个边界。反射能量的多少根据各组织的阻抗而定。通常见到的超声成像只用到了振幅信息。&lt;/p&gt;

&lt;p&gt;当一束超声波被发射出去，接收者每隔一小段时间就接收一下（取样）。因为超声的速度是恒定的，从超声发射出去到接收到反射回来信号的时间只与距离有关，也就是说与该组织的距离有关。这个距离对应到图像上就是深度信息。不同的组织结构反射回来的能量也不同，所以反射回来的信号携带两种信息：深度信息和振幅信息。下一条超声波什么时候发射取决于想探查的最大深度。&lt;/p&gt;

&lt;p&gt;用下面图来解释，P点投射出去一支超声波大军去撞墙（组织边界），有的小兵比较猛，直接穿墙，有的小兵头破血流地回来了（超声波被反射回来）。与此同时一个接收者在P点就等着统计返回来的小兵数量。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;

&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Amode.gif?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Amode1.JPG?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt; 
&lt;/table&gt; 
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;过了一秒，抬头检查，没人来，先休息下；又过了一秒，发现回来了几个小兵，这肯定是撞第一个墙的人来了。数一下人数和时间，休息去。&lt;/p&gt;

&lt;p&gt;过了一秒，抬头检查，没人来，难道剩下的小兵都很猛吗?休息去 
又过了一秒，抬头检查，没人来，这么猛？！休息去 
再过了一秒，还是没人来，这批人吃补药了？休息去。 
又过了一秒，抬头检查，回来一批。原来不是补药吃的好，是距离有点远耶。统计一下回来的人数，记录时间，休息去。&lt;/p&gt;

&lt;p&gt;就这样每隔一秒抬头检查一次，过了一段时间，又有一批小兵回来了，这应该是撞到第三面墙了，继续统计。继续……&lt;/p&gt;

&lt;p&gt;这里，统计员记录的时间就是深度信息（距离信息），统计的小兵人数就是对应的振幅信息。&lt;/p&gt;

&lt;p&gt;我们可以计算到，发射源与反射物体间的距离为声波速度与统计时间的乘积再除以2，为什么除以2？（因为小兵走了一个来回，与目的地之间的距离当然是一半了）&lt;/p&gt;

&lt;p&gt;某一时刻也就是某一深度接收到的能量值，以能量振幅的形式显示就是A型超声。以发射矩阵上某点的亮度值显示就是B型超声。如果有一些散射体在动，则可以让B型超声的点在屏幕上动起来，这就叫M型超声。&lt;/p&gt;

&lt;p&gt;可以参见下图，下图中离P点近的是第一个边界（散射体），最远的是第三个散射体。且第三个散射体在运动。A型超声反映每个散射体的深度和反射能量信息。B型超声以亮度表示反射回来的能量大小。最下面一个散射体在动，如果用时间曲线来反映，第三个反射体的运动就是一条曲线（M型超声）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table style=&quot;text-align: center; width: 100%;&quot; border=&quot;1&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/sektor_puls1.gif?raw=true&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/abm.gif?raw=true&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt; 
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;脉冲入射能量和反射能量的比例被称为反射系数（reflection efficient）；入射能量和透射能量的比例被称为透射系数（transmission coefficient）。这两个系数都取决于界面两侧材料的声阻抗。一种传输媒介的声阻抗定义为声音在该媒介中的传播速度c和该媒介的密度之积：公式1&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;z=c\times \rho&lt;/script&gt;

&lt;p&gt;因此，如果声音在两种媒介中的传播速度相差悬殊，则声音在其中间界面上的反射率接近100%，也就是说能量无法从第一个媒介传播到第二个媒介。这种情况常发生于软组织和骨头之间的界面，或者是软组织和空气之间的界面上。这时可以认为第二个媒介存在于阴影中。&lt;/p&gt;

&lt;p&gt;声波被以多个方向反射，反射波并不能直接返回发射器，因此这种反射结构也常被称为&lt;strong&gt;散射体&lt;/strong&gt;（scatterers）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是反射回探头的能量（也就是反射信号振幅）的多少，不只取决于反射系数，反射信号的方向同样重要。&lt;/strong&gt;&lt;br /&gt;
因此：&lt;br /&gt;
-无规律的，或者说不均匀的散射体只能将部分能量反射回探头
-在反射面垂直于超声波入射方向时，散射体越匀质，反射的能量越多。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1px&quot; width=&quot;80%&quot;&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Scatterers.GIF?raw=true&quot; width=&quot;100%&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;反射面大小和方向对反射能量的影响。左侧两图为平面反射面，当平面与入射波垂直，绝大部分能量将被反射回探头（这里并不是全部能量，因为入射波束前锋并不是平的）；当平面倾斜45度，几乎绝大部分能量将被反射到其他方向，探头接收到的反射能量微乎其微。中间两图展示了弯曲的散射面，这时会有更多能量被反射到不同方向，当然探头接收到的能量相对更少，但如果将散射面倾斜，可能会有更多能量反射到探头。比如，当心脏室壁收缩时，室壁方向就会发生变化。最后一张图展示了一个完全不规则的散射面，入射能量被反射到各个方向，但探头接收到的能量非常少。&lt;/b&gt;&lt;/small&gt;
&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br /&gt;

&lt;table border=&quot;1px&quot; width=&quot;100%&quot; align=&quot;center&quot;&gt;
&lt;tr&gt;
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/reflected%20direction.JPG?raw=true&quot; width=&quot;100%&quot; /&gt;&lt;/td&gt;		
&lt;td width=&quot;50%&quot;&gt;&lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/Tissuechar.jpg?raw=true&quot; width=&quot;100%&quot; /&gt;&lt;/td&gt;	
&lt;/tr&gt;	

&lt;tr&gt;		
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;上图为一幅左心室长轴图，反映了反射面方向不同所造成的影响。三处箭头所指处被称为隔血层（septum-blood interface），淡绿色箭头所指处由于表面垂直于超声波入射方向，其亮度要高于表面倾斜于入射波方向的区域（红色箭头）。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;&lt;p&gt;&lt;small&gt;&lt;b&gt;上图为心动周期内整体散射(integrated backscatter)振幅的周期性变化。这不是对心肌密度变化的反映，因为心肌是不能压缩的，所以振幅的变化大多数反映了心肌纤维的方向变化。&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;br /&gt;
&lt;/div&gt;

&lt;p&gt;注意：术语&lt;strong&gt;反射&lt;/strong&gt;指的是反射回探头的信号，而&lt;strong&gt;散射&lt;/strong&gt;(scattering)指的是各个方向上的反射信号。&lt;/p&gt;

&lt;p&gt;因此，超声图像上显示的组织密度取决于室壁和纤维方向。心脏某个部位的纤维方向与入射超声波垂直时，从图像上看密度较大。而实际上振幅（被反射信号的明暗）并不足以反映组织密度，也有可能是反射方向不同。因此，整体散射可以用来研究周期性变化，但不能用于研究组织特性。&lt;/p&gt;

&lt;p&gt;（下页继续）&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2016/07/11/ultrasound-introduction/</link>
        <guid isPermaLink="true">http://windtom.github.io/2016/07/11/ultrasound-introduction/</guid>
        
        <category>ultrasound</category>
        
        
        <category>ultrasound</category>
        
      </item>
    
      <item>
        <title>Creating a 2D Active Shape Model in ITK Using PCA</title>
        <description>&lt;p&gt;原帖地址: http://www.kitware.com/source/home/post/52&lt;/p&gt;

&lt;p&gt;ITK is an excellent example of an open-source framework in extreme programming. Strengths of the toolkit include superb documentation and list serve support, and a supportive and vibrant programming community. One missing area of documentation in the ITK software guide includes the implementation of itk::GeodesicActiveContourShapePriorLevelSetImageFilter. The generation of the active shape model (ASM) in this example is provided with no example code or images. Here, we provide sample images and commented code to generate an ASM using itk::ImagePCAShapeModelEstimator. We use the challenging problem of segmenting the femoral condyle cartilage of the knee in our example.&lt;/p&gt;

&lt;p&gt;Many classic described segmentation algorithms such as active contours (snakes), level set, and watershed rely on edge-based criteria [1-4].  For segmentation of articular femoral knee cartilage, a solely edge-based algorithm is inadequate because of the poor contrast at the cartilage and soft tissue interfaces.  One approach is to use a priori information to create an active shape model to help guide segmentation [5].&lt;/p&gt;

&lt;p&gt;The goal of an active shape model is to appropriately describe all of the allowed statistical variation of some generic shape.  The model is formed by using a training set of objects that are already segmented either manually or by some other automated or semi-automated method. The variation among the set of these previously segmented shapes is used to describe the variation of the shape model and therefore the training set needs to be a good representation of the overall distribution of allowable shapes.  This can be accomplished with a large sample size or good variation among the training images.&lt;/p&gt;

&lt;p&gt;Principal component analysis (PCA) is used to decompose the large variation in the natural shapes of a given object into a set of variables that describe the majority of the variation.  The basic steps of PCA include aligning the training images, finding the corresponding landmarks, computing the covariance matrix of these landmarks, and finally finding the determinate of the covariance matrix.&lt;/p&gt;

&lt;p&gt;In the first step of PCA, the training images should be transformed iteratively to maximize their overlapping area.  In the classical implementation, the N0 iteration consisted of the training images being registered with the first training image using a similarity transform that can rotate, scale, and translate the image.  After this first iteration, the mean image is computed.  For the following iterations, the training images are registered to the mean image, which is then recomputed. This process eventually converges and results in a set of training images aligned with maximal overlap. A subset of aligned training images used to create the femoral cartilage shape model are shown in Figure1.&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Oct 2014 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2014/10/14/creat-2d-asm-itk-pca/</link>
        <guid isPermaLink="true">http://windtom.github.io/2014/10/14/creat-2d-asm-itk-pca/</guid>
        
        <category>ITK</category>
        
        <category>ASM</category>
        
        <category>PCA</category>
        
        
        <category>MITK</category>
        
      </item>
    
      <item>
        <title>MITK中本来存在的头文件无法使用</title>
        <description>
&lt;p&gt;在使用MITK 插件的时候，我们会发现本来存在的头文件，mitk工程里却无法include进来，原因是project—properties—C/C++—General—-Additional Include Directories里并没有把相关头文件的文件路径添加进去。&lt;/p&gt;

&lt;p&gt;比如ITK Modules中Group Filtering内的 Module ITKColormap，我们无法引用里面的 itkScalarToRGBColormapImageFilter.h&lt;/p&gt;

&lt;p&gt;比较方便的办法是，找到插件源文件下的CMakeLists.txt文件，在里面加入&lt;code class=&quot;highlighter-rouge&quot;&gt;PACKAGE_DEPENDS ITK || ITKColorma&lt;/code&gt;。CMakeLists.txt内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;project(my_awesomeproject_myLevelSet)  
find_package (OPENCV REQUIRED)  
include_directories(${OPENCV_INCLUDE_DIRS})   
  
MACRO_CREATE_MITK_CTK_PLUGIN(  
  EXPORT_DIRECTIVE MYLEVELSET_EXPORT  
  EXPORTED_INCLUDE_SUFFIXES src  
  MODULE_DEPENDS MitkQtWidgetsExt MitkSegmentation  
  PACKAGE_DEPENDS ITK|ITKColormap  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 27 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2014/08/27/mitk-cant-use-headfile/</link>
        <guid isPermaLink="true">http://windtom.github.io/2014/08/27/mitk-cant-use-headfile/</guid>
        
        <category>mitk</category>
        
        <category>cmake</category>
        
        
        <category>MITK</category>
        
      </item>
    
      <item>
        <title>MITK--如何在源文件中引用自定义头文件</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;引用方法:&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;测试：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;替代方法：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;引用方法:&lt;/h3&gt;

&lt;p&gt;MITK编程中，我们常常需要自定义头文件，比如在VS工程里面给插件AddNoise创建一个头文件testHeadFile.h：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://github.com/WindTom/imagestom/blob/master/custom1.png?raw=true&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;但是这样做不好的地方在于：团队开发中，我们是上传MITK-ProjectTemplate源文件，其它成员下载源文件后CMake编译一下就能使用了。你自己在VS工程创建头文件后，VS并不会把它自动放入MITK-ProjectTemplate源文件里。所以其他成员在编译你上传的代码后，VS会提示找不到头文件。&lt;/p&gt;

&lt;p&gt;正确的做法是：将testHeadFile.h复制到源文件 MITK-ProjectTemplate\Plugins\my.awesomeproject.AddNoise\src文件夹内。&lt;/p&gt;

&lt;p&gt;同时修改MITK-ProjectTemplate\Plugins\my.awesomeproject.AddNoise文件夹下的files.cmake文件：set(SRC_CPP_FILES)里添加 itkAdditiveGaussianNoiseImageFilter.h和itkNoiseBaseImageFilter.h，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;  set(SRC_CPP_FILES  
  itkAdditiveGaussianNoiseImageFilter.h  
  itkNoiseBaseImageFilter.h  
  testHeadFile.h   //在此处添加 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;测试：&lt;/h3&gt;

&lt;p&gt;使用CMake重新编译MITK-ProjectTemplate，进行测试。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;替代方法：&lt;/h3&gt;

&lt;p&gt;如果上述方法不行，可以使用下述方法：&lt;/p&gt;

&lt;p&gt;同样，将testHeadFile.h复制到源文件 MITK-ProjectTemplate\Plugins\my.awesomeproject.AddNoise\src文件夹内。&lt;/p&gt;

&lt;p&gt;修改MITK-ProjectTemplate\Plugins\my.awesomeproject.AddNoise文件夹内的files.cmake,找到下列语句并将testHeadFile.h语句添加进去。如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;set(MOC_H_FILES  
  src/internal/my_awesomeproject_AddNoise_Activator.h  
  src/internal/AddNoise.h  
  src/itkAdditiveGaussianNoiseImageFilter.h  
  src/itkNoiseBaseImageFilter.h  
  testHeadFile.h  //在此处添加  
)  
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 04 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2014/08/04/mitk-include-custom-head-file/</link>
        <guid isPermaLink="true">http://windtom.github.io/2014/08/04/mitk-include-custom-head-file/</guid>
        
        <category>头文件</category>
        
        <category>MITK</category>
        
        
        <category>MITK</category>
        
      </item>
    
      <item>
        <title>C++通过ostringstream实现任意类型转string</title>
        <description>&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;c1&quot;&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;#include &amp;lt;string&amp;gt;  &lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;sr&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;头文件是&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sstream&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;oss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;---&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  
	   &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出是55—65.123。&lt;/p&gt;

&lt;p&gt;如果想实现小数点后只显示一位数字，使用下面方法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iostream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  
	&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sstream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  
	&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iomanip&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  
		
	&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  
	&lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
		&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setprecision&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
		
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;  
		&lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;66.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
		&lt;span class=&quot;nl&quot;&gt;std:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://windtom.github.io/2014/08/04/c-to-string/</link>
        <guid isPermaLink="true">http://windtom.github.io/2014/08/04/c-to-string/</guid>
        
        <category>CPlusPlus</category>
        
        <category>ostringstream</category>
        
        
        <category>CPlusPlus</category>
        
      </item>
    
  </channel>
</rss>
